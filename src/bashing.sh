#!/bin/bash

# -------------------------------------------------------------------
#
# bashing.sh:
#   This Script collects all source files and builds a single
#   stand-alone Script out of them.
#   (c) 2013 Yannick Scherer (yannick.scherer@gmail.com)
#
# -------------------------------------------------------------------
# USAGE
#
# bashing [<root-directory>] > <output file>
# bashing --lib-only [<root-director>] > <output file>
#
# -------------------------------------------------------------------
# DESCRIPTION
# This script expects a specific directory structure:
#
#   .
#   |- .project
#   |- src
#      |- cli
#         |- start.sh
#         |- stop.sh
#         |- ...
#      |- lib
#         |- <include files>
#
# It will create an executable shell script that consists of all the
# include files and offers the possiblity to let it be called using
#
#   ./<script> <cli-command> <param> ....
#
# E.g.: in our above case:
#
#   ./<script> start ...
#   ./<script> stop ...
#
# It will also contain logic to have the script installed locally or
# globally, as well as automatic help page and version printing.
#
# -------------------------------------------------------------------
# Global Data
BASHING_ROOT=$(cd "$(dirname "$0")" && pwd)
BASHING_VERSION="0.1.0-SNAPSHOT"

# Parameters
CWD=$(pwd)
PROJECT_ROOT=""
BUILD_HEADER="yes"
BUILD_LIBRARY="yes"
BUILD_CLI="yes"
BUILD_HELP="yes"
COMPACT_OUTPUT="no"
OUTPUT_FILE=""

# -------------------------------------------------------------------
# Tools

function print_out() {
    if [ -z "$OUTPUT_FILE" ]; then
        echo -e "$@";
    else
        echo -e "$@" >> "$OUTPUT_FILE"
    fi
}

function redirect_out() {
    local line=""
    while IFS='' read -r line; do
        print_out "$line";
    done
}

function sep() { 
    if [[ "$COMPACT_OUTPUT" != "yes" ]]; then
        print_out -n "# ";  
        print_out "$(head -c 45 /dev/zero | tr '\0' '-')"; 
    fi
}
function comment() { 
    if [[ "$COMPACT_OUTPUT" != "yes" ]]; then print_out "# $@"; fi; 
}
function nl() { 
    if [[ "$COMPACT_OUTPUT" != "yes" ]]; then print_out ""; fi; 
}

# -------------------------------------------------------------------
# Parse Command Line
while [ $# -gt 0 ]; do
    arg="$1"
    case "$arg" in
        "--out"|"-o") shift; OUTPUT_FILE="$1";;
        "--compact") COMPACT_OUTPUT="yes";;
        "--no-lib") BUILD_LIBRARY="no";;
        "--no-cli") BUILD_CLI="no";;
        "--no-header") BUILD_HEADER="no";;
        "--") shift; export PROJECT_ROOT="$1";;
        *)
            if [ -z "$PROJECT_ROOT" ]; then PROJECT_ROOT="$arg";
            else echo "Invalid command line argument: $arg" 1>&2; exit 1; fi
            ;;
    esac
    shift
done

# Check Parameters
if [ -z "$PROJECT_ROOT" ]; then PROJECT_ROOT=$(pwd); fi
PROJECT_ROOT=$(cd "$PROJECT_ROOT" && pwd);
if [ ! -d "$PROJECT_ROOT" ]; then
    echo "No such Directory: $PROJECT_ROOT" 1>&2;
    exit 1;
fi

if [ ! -z "$OUTPUT_FILE" ]; then
    OUTPUT_FILE="$(cd $(dirname "$OUTPUT_FILE") && pwd)/$(basename "$OUTPUT_FILE")"
    rm -f "$OUTPUT_FILE"
    if ! touch "$OUTPUT_FILE" 2> /dev/null; then
        echo "Cannot write to given Output File: $OUTPUT_FILE." 1>&2;
        exit 1;
    fi
fi

# Derive Paths
SRC_PATH="$PROJECT_ROOT/src"
CLI_PATH="$SRC_PATH/cli"
LIB_PATH="$SRC_PATH/lib"
CONF="$PROJECT_ROOT/bashing.meta"

# -------------------------------------------------------------------
# Read Configuration
RX_ID='[a-zA-Z_-]\+'
RX_INT='\(0\|[1-9][0-9]*\)'
RX_VERSION="$RX_INT\\.$RX_INT\\.$RX_INT\(-$RX_ID\\)\\?"
RX_ARTIFACT_STRING="^\\s*\\(\\($RX_ID\\)\\/\\)\\?\\($RX_ID\\)\\s\\+\\($RX_VERSION\\)\\s*$"
function artifact_get() { echo "$1" | sed -n "s/$RX_ARTIFACT_STRING/\\$2/p"; }

GROUP_ID=""
ARTIFACT_ID="unknown"
ARTIFACT_VERSION="0.1.0-SNAPSHOT"
AUTHOR=""
DESCRIPTION=""
URL=""
LICENSE=""

if [ -s "$CONF" ]; then
    artifactString=$(head -1 "$CONF")
    GROUP_ID=$(artifact_get "$artifactString" 2)
    ARTIFACT_ID=$(artifact_get "$artifactString" 3)
    ARTIFACT_VERSION=$(artifact_get "$artifactString" 4)

    if [ -z "$ARTIFACT_ID" -o -z "$ARTIFACT_VERSION" ]; then 
        echo "Invalid Artifact String in $CONF: $artifactString" 1>&2;
        exit 1;
    fi
fi
if [ -z "$GROUP_ID" ]; then GROUP_ID="$ARTIFACT_ID"; fi


# -------------------------------------------------------------------
# HEADER
if [[ "$BUILD_HEADER" == "yes" ]]; then
    print_out "#!/bin/bash"
    sep
    comment " Artifact:     $GROUP_ID/$ARTIFACT_ID"
    comment " Version:      $ARTIFACT_VERSION"
    comment " Date (UTC):   $(date -u)"
    comment " Generated by: bashing $BASHING_VERSION"
    sep
fi

# -------------------------------------------------------------------
# LIBRARY
function includeLibFile() {
    local path=""
    while read -r path; do
        local fullPath=$(cd "$SRC_PATH/$(dirname "$path")" && pwd)/$(basename "$path");
        if bash -n "$fullPath" 1> /dev/null; then
            comment "$path"
            sed '/^\s*#.*$/d' "$fullPath" | sed '/^\s*$/d' | redirect_out
        else
            return 1;
        fi
    done
    return 0
}

if [[ "$BUILD_LIBRARY" == "yes" ]] && [ -d "$LIB_PATH" ]; then
    nl
    comment "[library start]"
    cd "$SRC_PATH";
    find "./lib" -type f -name "*.sh" | includeLibFile
    if [[ "$?" != "0" ]]; then exit 1; fi
    comment "[library end]"
    cd "$CWD";
fi

# -------------------------------------------------------------------
# CLI 

function collectCliScripts() {
    cd "$CLI_PATH"
    find "." -type f -name "*.sh"
    cd "$CWD"
}

function toFn() {
    local n="$1"
    echo "cli_$(basename "${n:2}" ".sh")" | tr '/' '_' | sed 's/_+/_/g'
}

function toCliArg() {
    local n="$1"
    echo $(basename "${n:2}" ".sh") | tr '/' '.'
}

function includeCliFn() {
    local path="$1"
    local fnName=$(toFn "$path");
    local fullPath="$CLI_PATH/$path"

    # Checks
    if [[ "$fnName" == "cli_help" ]] && [[ "$BUILD_HELP" == "yes" ]]; then
        echo "WARN: CLI Function 'help' ($fullPath) overwrite built-in help." 1>&2;
        echo "WARN: Supply '--no-help' if you want to create your own help function." 1>&2;
    fi

    # Create
    if bash -n "$fullPath" 1> /dev/null; then
        comment "./cli/${path:2}"
        print_out "function ${fnName}() {"
        sed '/^\s*#.*$/d' "$fullPath"\
            | sed '/^\s*$/d'\
            | sed 's/exit/return/g'\
            | sed 's/^/  /g'\
            | redirect_out
        print_out "}"
        return 0;
    fi
    return 1;
}

function buildCliHandler() {
    local path="$1"
    local fnName=$(toFn "$path")
    local argName=$(toCliArg "$path")

    print_out "    \"$argName\")"
    print_out "      $fnName \"\$@\" &"
    print_out '      local pid="$!"'
    print_out '      ;;'
}

function buildCliHeader() {
    print_out "function __cli() {"
    print_out '  local pid=""'
    print_out '  local status=255'
    print_out '  local cmd="$1"'
    print_out '  shift'
    print_out '  case "$cmd" in'
    print_out '    "")'
    print_out '       __cli "help";'
    print_out '       return $?'
    print_out '       ;;'
}

function buildCliFooter() {
    print_out '  esac'
    print_out '  if [ ! -z "$pid" ]; then'
    print_out '      wait "$pid"'
    print_out '      local status=$?'
    print_out '  fi'
    print_out '  return $status'
    print_out "}"
}


function buildHelpTable() {
    for path in $@; do
        local argName=$(toCliArg "$path");
        echo "$argName|:|(no help available)"
    done
}

function buildHelpFunction() {
    print_out '    "help")'
    print_out '      echo "Usage: $0 <command> [<parameters> ...]" 1>&2'
    print_out '      echo 1>&2'
    print_out '      cat 1>&2 <<HELP'
    buildHelpTable "$@" | column -s "|" -t\
        | sed 's/^/    /'\
        | redirect_out
    print_out 'HELP'
    print_out '      echo 1>&2'
    print_out '      status=0'
    print_out '      ;;'
}

if [[ "$BUILD_CLI" == "yes" ]]; then
    cliScripts=$(collectCliScripts);

    set -e
    nl
    comment "[cli functions start]"
    for path in $cliScripts; do includeCliFn "$path"; done
    comment "[cli functions end]"
    nl
    comment "[cli start]"
    buildCliHeader
    for path in $cliScripts; do buildCliHandler "$path"; done
    if [[ "$BUILD_HELP" == "yes" ]]; then buildHelpFunction "$cliScripts"; fi
    buildCliFooter
    comment "[cli end]"
    nl
    sep
    print_out "__cli \"\$@\""
    cd "$CWD";
fi
