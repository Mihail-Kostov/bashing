#!/bin/bash
export __BASHING_VERSION='0.1.0-SNAPSHOT'
export __VERSION='0.1.0-SNAPSHOT'
export __ARTIFACT_ID='bashing'
export __GROUP_ID='bashing'
BASHING_ROOT=$(cd "$(dirname "$0")" && pwd)
BASHING_VERSION="0.1.0-SNAPSHOT"
BASHING_PROJECT_FILE="bashing.project"
CWD=$(pwd)
PROJECT_ROOT=$(pwd)
if [ ! -z "$1" ] && [[ "$1" != "help" ]]; then
    while [ -d "$PROJECT_ROOT" ]; do
        if [ -e "$PROJECT_ROOT/$BASHING_PROJECT_FILE" ]; then break; fi
        PROJECT_ROOT="$PROJECT_ROOT/.."
    done
    if [ ! -d "$PROJECT_ROOT" ]; then
        echo "Could not find Root Directory of this Project!" 1>&2
        exit 1;
    fi
    PROJECT_ROOT=$(cd "$PROJECT_ROOT" && pwd);
fi
PROJECT_FILE="$PROJECT_ROOT/$BASHING_PROJECT_FILE"
function print_out() {
    if [ -z "$OUT" ]; then
        echo "$@";
    else
        echo "$@" >> "$OUT"
    fi
}
function redirect_out() {
    local line=""
    while IFS='' read -r line; do
        print_out "$line";
    done
}
function sep() { 
    if [[ "$COMPACT" != "yes" ]]; then
        print_out -n "# ";  
        print_out "$(head -c 45 /dev/zero | tr '\0' '-')"; 
    fi
}
function comment() { 
    if [[ "$COMPACT" != "yes" ]]; then print_out "# $@"; fi; 
}
function nl() { 
    if [[ "$COMPACT" != "yes" ]]; then print_out ""; fi; 
}
function includeBashFile() {
    if [ -s "$1" ] && bash -n "$1"; then
        if [[ "$COMPACT" != "yes" ]]; then echo "# $1"; fi; 
        sed '/^\s*#.*$/d' "$1" | sed '/^\s*$/d';
    fi
}
function generateHeader() {
    print_out "#!/bin/bash"
    sep
    comment " Artifact:     $GROUP_ID/$ARTIFACT_ID"
    comment " Version:      $ARTIFACT_VERSION"
    comment " Date (UTC):   $(date -u)"
    comment " Generated by: bashing $BASHING_VERSION"
    sep
}
function generateMetadata() {
    print_out "export __BASHING_VERSION='$BASHING_VERSION'"
    print_out "export __VERSION='$ARTIFACT_VERSION'"
    print_out "export __ARTIFACT_ID='$ARTIFACT_ID'"
    print_out "export __GROUP_ID='$GROUP_ID'"
    sep
}
function genInclude() {
    if [ -s "$SRC_PATH/$1" ]; then
        cd "$SRC_PATH"
        includeBashFile "./$1" | redirect_out
        sep
        cd "$CWD"
    fi
}
function includeLibFile() {
    local path=""
    while read -r path; do
        local fullPath=$(cd "$SRC_PATH/$(dirname "$path")" && pwd)/$(basename "$path");
        if bash -n "$fullPath" 1> /dev/null; then
            includeBashFile "$path" | redirect_out
            nl
        else
            return 1;
        fi
    done
    return 0
}
function generateLibrary() {
    comment "Library"
    nl
    cd "$SRC_PATH";
    find "./lib" -type f -name "*.sh" | includeLibFile
    if [[ "$?" != "0" ]]; then exit 1; fi
    sep
    cd "$CWD";
}
function collectCliScripts() {
    if [ -d "$CLI_PATH" ]; then
        cd "$CLI_PATH"
        find "." -type f -name "*.sh"
        cd "$CWD"
    fi
}
function toFn() {
    local n="$1"
    echo "cli_$(basename "${n:2}" ".sh")" | tr '/' '_' | sed 's/_+/_/g'
}
function toCliArg() {
    local n="$1"
    echo $(basename "${n:2}" ".sh") | tr '/' '.'
}
function includeCliFn() {
    local path="$1"
    local fnName=$(toFn "$path");
    local fullPath="$CLI_PATH/$path"
    if [[ "$fnName" == "cli_help" ]] && [[ "$BUILD_HELP" == "yes" ]]; then
        echo "WARN: CLI Function 'help' ($fullPath) overwrite built-in help." 1>&2;
        echo "WARN: Supply '--no-help' if you want to create your own help function." 1>&2;
    fi
    if bash -n "$fullPath" 1> /dev/null; then
        comment "./cli/${path:2}"
        print_out "function ${fnName}() {"
        includeBashFile "$fullPath" | sed 's/^/  /g' | redirect_out
        print_out "}"
        return 0;
    fi
    return 1;
}
function buildCliHandler() {
    local path="$1"
    local fnName=$(toFn "$path")
    local argName=$(toCliArg "$path")
    print_out "    \"$argName\")"
    print_out "      $fnName \"\$@\" &"
    print_out '      local pid="$!"'
    print_out '      ;;'
}
function buildCliHeader() {
    print_out "function __run() {"
    print_out '  local pid=""'
    print_out '  local status=255'
    print_out '  local cmd="$1"'
    print_out '  shift'
    print_out '  case "$cmd" in'
    print_out '    "")'
    print_out '       __run "help";'
    print_out '       return $?'
    print_out '       ;;'
}
function buildCliFooter() {
    print_out '    *)'
    print_out '      echo "Unknown Command: $cmd" 1>&2;'
    print_out '      ;;'
    print_out '  esac'
    print_out '  if [ ! -z "$pid" ]; then'
    print_out '      wait "$pid"'
    print_out '      local status=$?'
    print_out '  fi'
    print_out '  return $status'
    print_out "}"
}
function buildHelpTable() {
    for path in $@; do
        local argName=$(toCliArg "$path");
        echo "$argName|:|(no help available)"
    done
}
function buildHelpFunction() {
    print_out '    "help")'
    print_out '      echo "Usage: $0 <command> [<parameters> ...]" 1>&2'
    if [ ! -z "$@" ]; then
        print_out '      cat 1>&2 <<HELP'
        print_out ''
        buildHelpTable "$@" | column -s "|" -t\
            | sed 's/^/    /'\
            | redirect_out
        print_out ''
        print_out 'HELP'
    fi
    print_out '      status=0'
    print_out '      ;;'
}
function generateCli() {
    cliScripts=$(collectCliScripts);
    set -e
    comment "CLI Functions"
    nl
    for path in $cliScripts; do includeCliFn "$path"; done
    sep
    comment "Main Function"
    nl
    buildCliHeader
    for path in $cliScripts; do buildCliHandler "$path"; done
    if [[ "$BUILD_HELP" == "yes" ]]; then buildHelpFunction "$cliScripts"; fi
    buildCliFooter
    print_out "__run \"\$@\""
    print_out 'export __STATUS="$?"'
    sep
    cd "$CWD";
}
function generateCliExit() {
    print_out 'exit $__STATUS'
}
RED="`tput setaf 1`"
GREEN="`tput setaf 2`"
YELLOW="`tput setaf 3`"
BLUE="`tput setaf 4`"
MAGENTA="`tput setaf 5`"
CYAN="`tput setaf 6`"
WHITE="`tput setaf 7`"
RESET="`tput sgr0`"
function colorize() {
    if [[ "$USE_COLORS" != "no" ]]; then
        c="$1"
        shift
        echo -n ${c}${@}${RESET};
    else
        shift
        echo -n "$@";
    fi
}
function green() { colorize "${GREEN}" "${@}"; }
function red() { colorize "${RED}" "${@}"; }
function yellow() { colorize "${YELLOW}" "${@}"; }
function blue() { colorize "${BLUE}" "${@}"; }
function magenta() { colorize "${MAGENTA}" "${@}"; }
function cyan() { colorize "${CYAN}" "${@}"; }
function white() { colorize "${WHITE}" "${@}"; }
RX_ID='[a-zA-Z_-]\+'
RX_INT='\(0\|[1-9][0-9]*\)'
RX_VERSION="$RX_INT\\.$RX_INT\\.$RX_INT\(-$RX_ID\\)\\?"
RX_ARTIFACT_STRING="^\\s*\\(\\($RX_ID\\)\\/\\)\\?\\($RX_ID\\)\\s\\+\\($RX_VERSION\\)\\s*$"
function artifactString() { head -n 1 "$PROJECT_FILE"; }
function artifactGet() { echo "$1" | sed -n "s/$RX_ARTIFACT_STRING/\\$2/p"; }
function artifactVersion() { artifactGet "$1" 4; }
function artifactId() { artifactGet "$1" 3; }
function artifactGroupId() { artifactGet "$1" 2; }
function error() {
    echo -n "$(red "(ERROR)") " 1>&2
    echo "$@" 1>&2
}
GROUP_ID=""
ARTIFACT_ID=""
ARTIFAT_VERSION=""
if [[ "$1" == "compile" ]]; then
    s=$(artifactString)
    GROUP_ID=$(artifactGroupId "$s")
    ARTIFACT_ID=$(artifactId "$s")
    ARTIFACT_VERSION=$(artifactVersion "$s")
    if [ -z "$ARTIFACT_ID" -o -z "$ARTIFACT_VERSION" ]; then 
        error "Invalid Artifact String in $BASHING_PROJECT_FILE: $s";
        exit 1;
    fi
    if [ -z "$GROUP_ID" ]; then GROUP_ID="$ARTIFACT_ID"; fi
fi
function cli_compile() {
  BUILD_HEADER="yes"
  BUILD_METADATA="yes"
  BUILD_LIBRARY="yes"
  BUILD_CLI="yes"
  BUILD_HELP="yes"
  COMPACT="no"
  OUTPUT_FILE=""
  while [ $# -gt 0 ]; do
      arg="$1"
      case "$arg" in
          "--out"|"-o") shift; OUTPUT_FILE="$1";;
          "--compact") COMPACT="yes";;
          "--no-metadata") BUILD_METADATA="no";;
          "--no-lib") BUILD_LIBRARY="no";;
          "--no-cli") BUILD_CLI="no";;
          "--no-header") BUILD_HEADER="no";;
          --*)
              error "Invalid command line argument: $arg"
              exit 1
              ;;
          *)
              if [ -z "$PROJECT_ROOT" ]; then PROJECT_ROOT="$arg";
              else error "Invalid command line argument: $arg"; exit 1; fi
              ;;
      esac
      shift
  done
  if [ ! -z "$OUTPUT_FILE" ]; then
      OUTPUT_FILE="$(cd $(dirname "$OUTPUT_FILE") && pwd)/$(basename "$OUTPUT_FILE")"
      rm -f "$OUTPUT_FILE"
      if ! touch "$OUTPUT_FILE" 2> /dev/null; then
          error "Cannot write to given Output File: $OUTPUT_FILE.";
          exit 1;
      fi
      export OUT="$OUTPUT_FILE"
  fi
  SRC_PATH="$PROJECT_ROOT/src"
  CLI_PATH="$SRC_PATH/cli"
  LIB_PATH="$SRC_PATH/lib"
  cd "$SRC_PATH"
  if [[ "$BUILD_HEADER" == "yes" ]]; then generateHeader; fi
  if [[ "$BUILD_METADATA" == "yes" ]]; then generateMetadata; fi
  genInclude "setup.sh"
  if [[ "$BUILD_LIBRARY" == "yes" ]] && [ -d "$LIB_PATH" ]; then generateLibrary; fi
  if [[ "$BUILD_CLI" == "yes" ]]; then 
      genInclude "before-cli.sh"
      generateCli
      genInclude "after-cli.sh"
  fi
  genInclude "shutdown.sh"
  if [[ "$BUILD_CLI" == "yes" ]]; then generateCliExit; fi
  cd "$CWD"
}
function __run() {
  local pid=""
  local status=255
  local cmd="$1"
  shift
  case "$cmd" in
    "")
       __run "help";
       return $?
       ;;
    "compile")
      cli_compile "$@" &
      local pid="$!"
      ;;
    "help")
      echo "Usage: $0 <command> [<parameters> ...]" 1>&2
      cat 1>&2 <<HELP

    compile  :  (no help available)

HELP
      status=0
      ;;
    *)
      echo "Unknown Command: $cmd" 1>&2;
      ;;
  esac
  if [ ! -z "$pid" ]; then
      wait "$pid"
      local status=$?
  fi
  return $status
}
__run "$@"
export __STATUS="$?"
exit $__STATUS
